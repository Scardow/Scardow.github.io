{"meta":{"title":"Scardow's blog","subtitle":"","description":"","author":"Scarce Shadow","url":"https://scardow.github.io","root":"/"},"pages":[{"title":"about","date":"2017-05-31T02:05:56.000Z","updated":"2021-08-18T11:32:33.796Z","comments":true,"path":"about/index.html","permalink":"https://scardow.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-08-16T12:03:43.000Z","updated":"2021-08-16T12:03:43.143Z","comments":true,"path":"categories/index.html","permalink":"https://scardow.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-08-16T12:03:26.000Z","updated":"2021-08-16T12:03:26.942Z","comments":true,"path":"tags/index.html","permalink":"https://scardow.github.io/tags/index.html","excerpt":"","text":""},{"title":"PWN","date":"2021-08-17T00:12:24.000Z","updated":"2021-08-17T00:12:24.961Z","comments":true,"path":"categories/PWN/index.html","permalink":"https://scardow.github.io/categories/PWN/index.html","excerpt":"","text":""}],"posts":[{"title":"Heap Exploitation（主要记录知识框架和利用技巧，更多细节不在此记录）","slug":"Heap Exploitation","date":"2021-08-16T23:54:01.000Z","updated":"2021-08-24T09:34:05.243Z","comments":true,"path":"2021/08/17/Heap Exploitation/","link":"","permalink":"https://scardow.github.io/2021/08/17/Heap%20Exploitation/","excerpt":"本文主要记录堆利用手法，并会随学习过程不断补充","text":"本文主要记录堆利用手法，并会随学习过程不断补充 Heap intro briefHeap memory allocator ptmalloc2 - glibc … (先记录glibc，复杂的堆管理器之后学) Mechanism of glibc malloc堆中数据结构 malloc分配最小空间（SIZE_T*4） chunk 结构 chunk头 + data Chunk 分类allocated chunk prev_size 若连续记忆体上一堆块为free chunk，prev_size为前一个堆块大小 若连续记忆体上一块为allocated chunk，则为上一块的data size由于size大小存在对齐，所以size后三比特始终为零，因此可以保存三个flag PREV_INUSE (bit 0): 上一块是否allocated IS_MMAPPED(bit 1): 该chunk是否由mmap分配 NON_MAIN_ARENA(bit 2): 是否不属于main arena free chunk ( bin ) prev_size size 同allocated chunk fd：指向链表的下一个chunk( 含bin头 ) bk: 指向链表的前一个chunk( 含bin头 ) fd_nextsize: 指向下一个large chunk( 不含bin头 ) bk_nextsize: 指向前一个large chunk( 不含bin头 ) top chunk 第一次malloc分配的heap为main arena，未分配的大堆块为top chunk last remainder malloc分配时unsorted bin切块后存入，unsorted bin仍存在 binchunk free后进入bin fast bin 单向链表, 相同大小在一条链上 LIFO 不会把下一块chunk P设置成0 size分为0x20，0x30，0x40 … 0x80 global_max_fast = 0x80 small bin 双向链环, 相同大小在一条链上 FIFO 会把下一块chunk P设置成0 size: 0x20, 0x30, 0x40 … 0x90 … 0x3f0 按照size大小分为62个bin, 分别为2~63 下标 SIZE_SZ=8（64 位） 2 0x20 3 0x30 4 0x40 5 0x50 X 0xX0 63(3F) 0x3f0 其中0x20 … 0x90为unsorted bin切割后分配的 large bin 双向链环(sorted) size &gt;= 1024(0x400) 组 数量 公差 1 32 64B 2 16 512B 3 8 4096B 4 4 32768B 5 2 262144B 6 1 不限制 unsorted bin 双向链环 free chunk大小大于0x80, glibc将chunk先放入unsorted bin malloc的执行过程 第一次malloc：当申请内存空间 &lt;128 KB 时， kernel分配132KB的heap；&gt;128KB 时，使用mmap分配内存 第二次及之后： fastbin(LIFO) bins 按照索引从小到大查找 top chunk 向kernel索要空间 free 的执行过程与chunk的合并 free chunk先看上一块是否为free chunk(P位是否为0)，若是，则于前一堆块合并，在对前一个堆块unlink 再看下一堆块： top chunk: 与之合并（第二步使用的是合并之后的堆块） free：合并后一同加入unsorted bin inuse：加入unsorted bin 堆利用手法UAFfree(pointer) 后未将指针ptr清空, 该ptr称作dangling pointer，即为一个pointer指向一块释放的记忆体. 利用 infomation leak struct type confusion double free 参考资料： CTFwiki Angleboy的PPT","categories":[],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://scardow.github.io/tags/PWN/"}]}],"categories":[],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://scardow.github.io/tags/PWN/"}]}